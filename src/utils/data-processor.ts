// src/utils/data-processor.ts (fixed)

import { CustomerDisplayData, SubscriptionPlan, SubscriptionStatus, PaymentStatus, ChurnRiskLevel } from '@/types/api';

export interface ImportCustomerData {
  name: string;
  email: string;
  plan: string;
  monthlyRevenue: number;
  subscriptionStartDate: string;
  lastActivity: string;
  companyName?: string;
  phoneNumber?: string;
}

/**
 * Processes imported customer data and calculates derived fields
 * Returns CustomerDisplayData instead of CustomerData since we're creating display-friendly data
 */
export const processImportedCustomers = (importedCustomers: ImportCustomerData[]): CustomerDisplayData[] => {
  return importedCustomers.map((imported, index) => {
    const subscriptionStart = new Date(imported.subscriptionStartDate);
    const lastActivity = new Date(imported.lastActivity);
    const now = new Date();

    // Calculate months subscribed
    const monthsSubbed = calculateMonthsBetween(subscriptionStart, now);

    // Calculate LTV (simplified calculation)
    const ltv = calculateLifetimeValue(imported.monthlyRevenue, monthsSubbed);

    // Calculate churn risk based on various factors
    const churnRisk = calculateChurnRisk({
      daysSinceLastActivity: calculateDaysBetween(lastActivity, now),
      monthsSubbed,
      monthlyRevenue: imported.monthlyRevenue,
      plan: imported.plan
    });

    // Determine activity frequency
    const activityFrequency = determineActivityFrequency(
      calculateDaysBetween(lastActivity, now)
    );

    // Parse name into first and last name
    const nameParts = imported.name.trim().split(' ');
    const firstName = nameParts[0] || '';
    const lastName = nameParts.slice(1).join(' ') || '';

    // Map plan string to enum
    const planEnum = mapPlanStringToEnum(imported.plan);

    return {
      id: `imported-${Date.now()}-${index}`, // In real app, this would be generated by the backend
      name: imported.name,
      email: imported.email,
      monthsSubbed,
      ltv: formatCurrency(ltv),
      churnRisk,
      activityFrequency,
      lastActivity: imported.lastActivity,
      plan: imported.plan,
      planEnum,
      subscriptionStatus: SubscriptionStatus.Active, // Default for imported customers
      paymentStatus: PaymentStatus.Current, // Default for imported customers
      churnRiskLevel: mapChurnRiskToLevel(churnRisk),
    } as CustomerDisplayData;
  });
};

/**
 * Map plan string to SubscriptionPlan enum
 */
const mapPlanStringToEnum = (planString: string): SubscriptionPlan => {
  const planLower = planString.toLowerCase();
  if (planLower.includes('enterprise')) return SubscriptionPlan.Enterprise;
  if (planLower.includes('pro')) return SubscriptionPlan.Pro;
  return SubscriptionPlan.Basic; // Default fallback
};

/**
 * Map churn risk score to ChurnRiskLevel enum
 */
const mapChurnRiskToLevel = (riskScore: number): ChurnRiskLevel => {
  if (riskScore >= 80) return ChurnRiskLevel.Critical;
  if (riskScore >= 60) return ChurnRiskLevel.High;
  if (riskScore >= 40) return ChurnRiskLevel.Medium;
  return ChurnRiskLevel.Low;
};

/**
 * Calculate months between two dates
 */
const calculateMonthsBetween = (startDate: Date, endDate: Date): number => {
  const yearDiff = endDate.getFullYear() - startDate.getFullYear();
  const monthDiff = endDate.getMonth() - startDate.getMonth();
  return Math.max(1, yearDiff * 12 + monthDiff);
};

/**
 * Calculate days between two dates
 */
const calculateDaysBetween = (startDate: Date, endDate: Date): number => {
  const timeDiff = endDate.getTime() - startDate.getTime();
  return Math.ceil(timeDiff / (1000 * 3600 * 24));
};

/**
 * Calculate lifetime value based on monthly revenue and subscription duration
 */
const calculateLifetimeValue = (monthlyRevenue: number, monthsSubbed: number): number => {
  // Simple LTV calculation: monthly revenue * months subscribed
  // In a real system, you might use more sophisticated models
  return monthlyRevenue * monthsSubbed;
};

/**
 * Calculate churn risk score (0-100)
 */
const calculateChurnRisk = (factors: {
  daysSinceLastActivity: number;
  monthsSubbed: number;
  monthlyRevenue: number;
  plan: string;
}): number => {
  let riskScore = 0;

  // Activity-based risk (40% weight)
  if (factors.daysSinceLastActivity > 30) {
    riskScore += 40;
  } else if (factors.daysSinceLastActivity > 14) {
    riskScore += 25;
  } else if (factors.daysSinceLastActivity > 7) {
    riskScore += 10;
  }

  // Tenure-based risk (20% weight)
  if (factors.monthsSubbed < 3) {
    riskScore += 20; // New customers are higher risk
  } else if (factors.monthsSubbed < 12) {
    riskScore += 10;
  } else if (factors.monthsSubbed > 24) {
    riskScore -= 5; // Long-term customers are lower risk
  }

  // Revenue-based risk (25% weight)
  if (factors.monthlyRevenue < 50) {
    riskScore += 25; // Lower value customers are higher risk
  } else if (factors.monthlyRevenue < 100) {
    riskScore += 15;
  } else if (factors.monthlyRevenue > 200) {
    riskScore -= 10; // High-value customers are lower risk
  }

  // Plan-based risk (15% weight)
  const planRisk = {
    'Basic': 15,
    'Pro': 8,
    'Enterprise': 3,
    'Starter': 12,
    'Premium': 5,
    'Business': 6
  };
  riskScore += planRisk[factors.plan as keyof typeof planRisk] || 10;

  // Ensure score is between 0 and 100
  return Math.max(0, Math.min(100, Math.round(riskScore)));
};

/**
 * Determine activity frequency based on days since last activity
 */
const determineActivityFrequency = (daysSinceLastActivity: number): 'High' | 'Medium' | 'Low' => {
  if (daysSinceLastActivity <= 3) return 'High';
  if (daysSinceLastActivity <= 14) return 'Medium';
  return 'Low';
};

/**
 * Format number as currency
 */
const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount);
};

/**
 * Validate customer data before processing
 */
export const validateCustomerData = (customer: ImportCustomerData): string[] => {
  const errors: string[] = [];

  // Required field validation
  if (!customer.name?.trim()) errors.push('Name is required');
  if (!customer.email?.trim()) errors.push('Email is required');
  if (!customer.plan?.trim()) errors.push('Plan is required');

  // Email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (customer.email && !emailRegex.test(customer.email)) {
    errors.push('Invalid email format');
  }

  // Revenue validation
  if (typeof customer.monthlyRevenue !== 'number' || customer.monthlyRevenue < 0) {
    errors.push('Monthly revenue must be a positive number');
  }

  // Date validation
  const subscriptionDate = new Date(customer.subscriptionStartDate);
  const lastActivityDate = new Date(customer.lastActivity);
  
  if (isNaN(subscriptionDate.getTime())) {
    errors.push('Invalid subscription start date');
  }
  
  if (isNaN(lastActivityDate.getTime())) {
    errors.push('Invalid last activity date');
  }

  // Business logic validation
  if (!isNaN(subscriptionDate.getTime()) && subscriptionDate > new Date()) {
    errors.push('Subscription start date cannot be in the future');
  }

  if (!isNaN(lastActivityDate.getTime()) && !isNaN(subscriptionDate.getTime())) {
    if (lastActivityDate < subscriptionDate) {
      errors.push('Last activity cannot be before subscription start date');
    }
  }

  // Plan validation
  const validPlans = ['Basic', 'Pro', 'Enterprise', 'Starter', 'Premium', 'Business'];
  if (customer.plan && !validPlans.includes(customer.plan)) {
    errors.push(`Invalid plan. Must be one of: ${validPlans.join(', ')}`);
  }

  return errors;
};

/**
 * Generate customer insights from imported data
 */
export const generateImportInsights = (customers: ImportCustomerData[]) => {
  const insights = {
    totalCustomers: customers.length,
    averageRevenue: 0,
    planDistribution: {} as Record<string, number>,
    riskDistribution: {
      high: 0,    // >70% risk
      medium: 0,  // 40-70% risk
      low: 0      // <40% risk
    },
    newCustomers: 0, // subscribed in last 3 months
    averageTenure: 0,
    totalMRR: 0,
    estimatedChurnRisk: 0
  };

  if (customers.length === 0) return insights;

  // Calculate metrics
  const now = new Date();
  let totalRevenue = 0;
  let totalTenureMonths = 0;
  let totalChurnRisk = 0;

  customers.forEach(customer => {
    // Revenue
    totalRevenue += customer.monthlyRevenue;

    // Plan distribution
    insights.planDistribution[customer.plan] = (insights.planDistribution[customer.plan] || 0) + 1;

    // Tenure and new customers
    const subscriptionDate = new Date(customer.subscriptionStartDate);
    const monthsSubbed = calculateMonthsBetween(subscriptionDate, now);
    totalTenureMonths += monthsSubbed;
    
    if (monthsSubbed <= 3) {
      insights.newCustomers++;
    }

    // Calculate churn risk for distribution
    const daysSinceLastActivity = calculateDaysBetween(new Date(customer.lastActivity), now);
    const churnRisk = calculateChurnRisk({
      daysSinceLastActivity,
      monthsSubbed,
      monthlyRevenue: customer.monthlyRevenue,
      plan: customer.plan
    });

    totalChurnRisk += churnRisk;

    if (churnRisk > 70) insights.riskDistribution.high++;
    else if (churnRisk > 40) insights.riskDistribution.medium++;
    else insights.riskDistribution.low++;
  });

  insights.averageRevenue = totalRevenue / customers.length;
  insights.averageTenure = totalTenureMonths / customers.length;
  insights.totalMRR = totalRevenue;
  insights.estimatedChurnRisk = totalChurnRisk / customers.length;

  return insights;
};

/**
 * Parse name field to handle different formats
 */
export const parseName = (nameField: string): { firstName: string; lastName: string; fullName: string } => {
  const trimmedName = nameField.trim();
  const nameParts = trimmedName.split(' ');
  
  if (nameParts.length === 1) {
    return {
      firstName: nameParts[0],
      lastName: '',
      fullName: trimmedName
    };
  }
  
  return {
    firstName: nameParts[0],
    lastName: nameParts.slice(1).join(' '),
    fullName: trimmedName
  };
};

/**
 * Clean and normalize phone numbers
 */
export const normalizePhoneNumber = (phone: string): string => {
  if (!phone) return '';
  
  // Remove all non-numeric characters except + at the beginning
  const cleaned = phone.replace(/(?!^\+)\D/g, '');
  
  // Add + if it starts with a country code but no +
  if (cleaned.length > 10 && !cleaned.startsWith('+')) {
    return '+' + cleaned;
  }
  
  return cleaned;
};