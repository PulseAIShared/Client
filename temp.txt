import React, { useEffect, useMemo, useState, useRef, useCallback } from 'react';
import type { IconType } from 'react-icons';
import { SiHubspot, SiPosthog, SiStripe } from 'react-icons/si';
import { Button } from '@/components/ui/button';
import { Spinner } from '@/components/ui/spinner';
import { useNotifications } from '@/components/ui/notifications';
import { CompanyAuthorization, useAuthorization } from '@/lib/authorization';
import { signalRConnection } from '@/lib/signalr';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { useModal } from '@/app/modal-provider';
import {
  useGetIntegrations,
  useStartConnection,
  useReconnectIntegration,
  useTriggerSync,
  useDisconnectIntegration,
  useTestConnection,
  useConfigureIntegration,
  useGetAllConfigurationOptions,
  useGetConfigurationOptions,
  useGetSyncJobs,
  useInspectIntegration,
  inspectIntegration,
  parseIntegrationProblem,
} from '../api/integrations';
import { IntegrationStatus } from '@/types/api';
import type {
  ConfigurationOptions,
  IntegrationStatusResponse,
  IntegrationInspection,
  IntegrationSyncJobSummary,
  SyncConfigRequest,
  ProblemDetails,
} from '@/types/api';
import { IntegrationConfigModal } from './integration-config-modal';
import { cleanupExpiredOAuthSessions, persistOAuthSession } from '../lib/oauth-session';

type IntegrationCategory = 'crm' | 'email' | 'payment' | 'analytics' | 'support' | 'other';

type ProviderMetadata = {
  type: string;
  name: string;
  description: string;
  category: IntegrationCategory;
  features: string[];
  initials: string;
  icon?: IconType;
  accentGradient?: string;
};

const PROVIDER_CATALOG: Record<string, ProviderMetadata> = {
  Stripe: {
    type: 'Stripe',
    name: 'Stripe',
    description: 'Stream payment activity, subscriptions, and revenue signals.',
    category: 'payment',
    features: ['Payments', 'Subscriptions', 'Invoices'],
    initials: 'ST',
    icon: SiStripe,
    accentGradient: 'from-[#6772e5] to-[#3a39c5]',
  },
  HubSpot: {
    type: 'HubSpot',
    name: 'HubSpot',
    description: 'Sync contacts, companies, deals, and engagement metrics.',
    category: 'crm',
    features: ['Contacts', 'Companies', 'Deals'],
    initials: 'HS',
    icon: SiHubspot,
    accentGradient: 'from-[#ff7a59] to-[#d62d20]',
  },
  PostHog: {
    type: 'PostHog',
    name: 'PostHog',
    description: 'Activate product analytics, event pipelines, and experiment data.',
    category: 'analytics',
    features: ['Event Pipelines', 'Product Analytics', 'Experiments'],
    initials: 'PH',
    icon: SiPosthog,
    accentGradient: 'from-[#ff6f63] to-[#6d3df6]',
  },
};

const CATEGORY_GRADIENTS: Record<IntegrationCategory, string> = {
  crm: 'from-[#ff7a59] to-[#d62d20]',
  email: 'from-[#fbab7e] to-[#f7ce68]',
  payment: 'from-[#6772e5] to-[#3a39c5]',
  analytics: 'from-[#ff6f63] to-[#6d3df6]',
  support: 'from-[#00bcd4] to-[#0052d4]',
  other: 'from-accent-primary to-accent-secondary',
};

const STATUS_META: Record<IntegrationStatus, { label: string; badge: string; dot: string }> = {
  [IntegrationStatus.Connected]: {
    label: 'Connected',
    badge: 'bg-success/15 text-success border border-success/30',
    dot: 'bg-success',
  },
  [IntegrationStatus.NotConnected]: {
    label: 'Not connected',
    badge: 'bg-surface-secondary/70 text-text-secondary border border-border-primary/40',
    dot: 'bg-border-primary',
  },
  [IntegrationStatus.Error]: {
    label: 'Error',
    badge: 'bg-error/15 text-error-muted border border-error/30',
    dot: 'bg-error-muted',
  },
  [IntegrationStatus.Syncing]: {
    label: 'Sync in progress',
    badge: 'bg-info/15 text-info border border-info/30',
    dot: 'bg-info',
  },
  [IntegrationStatus.TokenExpired]: {
    label: 'Token expired',
    badge: 'bg-warning/15 text-warning border border-warning/30',
    dot: 'bg-warning',
  },
};

const StatusBadge: React.FC<{ status: IntegrationStatus }> = ({ status }) => {
  const meta = STATUS_META[status] ?? STATUS_META[IntegrationStatus.Error];

  return (
    <span className={`inline-flex items-center gap-2 rounded-full px-3 py-1 text-xs font-medium ${meta.badge}`}>
      <span className={`h-2 w-2 rounded-full ${meta.dot}`} />
      {meta.label}
    </span>
  );
};

const getProviderMetadata = (type: string): ProviderMetadata => {
  const fromCatalog = PROVIDER_CATALOG[type];
  if (fromCatalog) {
    return fromCatalog;
  }

  return {
    type,
    name: type,
    description: 'Connect this provider to manage sync schedules and mappings.',
    category: 'other',
    features: [],
    initials: type.slice(0, 2).toUpperCase(),
    accentGradient: CATEGORY_GRADIENTS.other,
  };
};

const formatRelativeTime = (value?: string | null): string => {
  if (!value) {
    return 'Never';
  }

  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return 'Unknown';
  }

  const diff = date.getTime() - Date.now();
  const isFuture = diff > 0;
  const absMinutes = Math.round(Math.abs(diff) / (60 * 1000));

  if (absMinutes < 1) {
    return isFuture ? 'in <1 minute' : '<1 minute ago';
  }

  if (absMinutes < 60) {
    return isFuture
      ? `in ${absMinutes} minute${absMinutes === 1 ? '' : 's'}`
      : `${absMinutes} minute${absMinutes === 1 ? '' : 's'} ago`;
  }

  const absHours = Math.round(absMinutes / 60);
  if (absHours < 24) {
    return isFuture
      ? `in ${absHours} hour${absHours === 1 ? '' : 's'}`
      : `${absHours} hour${absHours === 1 ? '' : 's'} ago`;
  }

  const absDays = Math.round(absHours / 24);
  if (absDays < 30) {
    return isFuture
      ? `in ${absDays} day${absDays === 1 ? '' : 's'}`
      : `${absDays} day${absDays === 1 ? '' : 's'} ago`;
  }

  return date.toLocaleDateString();
};

const formatAbsolute = (value?: string | null): string => {
  if (!value) {
    return '--';
  }

  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return '--';
  }

  return date.toLocaleString();
};

const ProviderIcon: React.FC<{ provider: ProviderMetadata; size?: 'md' | 'lg' }> = ({ provider, size = 'md' }) => {
  const IconComponent = provider.icon;
  const gradient = provider.accentGradient ?? CATEGORY_GRADIENTS[provider.category] ?? CATEGORY_GRADIENTS.other;
  const wrapperSize = size === 'lg' ? 'h-14 w-14 text-3xl' : 'h-12 w-12 text-2xl';
  const iconSize = size === 'lg' ? 'h-7 w-7' : 'h-6 w-6';

  return (
    <div
      className={`flex ${wrapperSize} items-center justify-center rounded-xl bg-gradient-to-br ${gradient} text-white shadow-md ring-1 ring-black/10`}
    >
      {IconComponent ? (
        <IconComponent className={iconSize} aria-hidden="true" />
      ) : (
        <span className="text-sm font-semibold uppercase">{provider.initials}</span>
      )}
    </div>
  );
};

const StatCard: React.FC<{ label: string; value: React.ReactNode; helper?: React.ReactNode }> = ({
  label,
  value,
  helper,
}) => {
  return (
    <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/70 p-4 shadow-sm">
      <span className="text-xs uppercase tracking-wide text-text-muted">{label}</span>
      <div className="mt-2 text-lg font-semibold text-text-primary">{value}</div>
      {helper ? <div className="mt-1 text-xs text-text-secondary">{helper}</div> : null}
    </div>
  );
};

const logIntegrationProblem = (
  context: string,
  problem: ProblemDetails,
  extra?: Record<string, unknown>
) => {
  const details = {
    traceId: problem.traceId ?? null,
    code: problem.code ?? null,
    metadata: problem.metadata ?? null,
    ...extra,
  };

  // eslint-disable-next-line no-console
  console.error(`[Integrations] ${context}`, details);
};

type InspectModalProps = {
  integration: IntegrationStatusResponse;
  inspection: IntegrationInspection | null;
  isLoading: boolean;
  error?: string | null;
  onClose: () => void;
};

const InspectModal: React.FC<InspectModalProps> = ({
  integration,
  inspection,
  isLoading,
  error,
  onClose,
}) => {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-bg-primary/60 backdrop-blur-sm p-4">
      <div className="w-full max-w-2xl rounded-2xl border border-border-primary/40 bg-surface-primary/95 p-6 shadow-2xl">
        <div className="mb-4 flex items-start justify-between gap-4">
          <div>
            <h2 className="text-lg font-semibold text-text-primary">
              Integration capabilities — {integration.name}
            </h2>
            <p className="text-sm text-text-secondary">
              Review objects, permissions, and mapping recommendations reported by the provider.
            </p>
          </div>
          <button
            onClick={onClose}
            className="rounded-lg p-2 text-text-muted transition-colors hover:bg-surface-secondary/60 hover:text-text-primary"
            aria-label="Close capabilities dialog"
          >
            <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {isLoading ? (
          <div className="flex items-center justify-center py-10">
            <Spinner size="lg" className="text-accent-primary" />
          </div>
        ) : error ? (
          <div className="rounded-xl border border-error/30 bg-error/10 p-4 text-sm text-error-muted">{error}</div>
        ) : inspection ? (
          <div className="space-y-6">
            <div className="space-y-3">
              <h3 className="text-sm font-semibold uppercase tracking-wide text-text-secondary">Data types</h3>
              <div className="grid gap-3 md:grid-cols-2">
                {inspection.dataTypes.map((dataType) => (
                  <div
                    key={dataType.id}
                    className="rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-4"
                  >
                    <div className="flex items-center justify-between gap-3">
                      <span className="text-sm font-semibold text-text-primary">{dataType.label}</span>
                      <span
                        className={`text-xs font-medium ${
                          dataType.supported && dataType.permissionOk ? 'text-success' : 'text-warning-muted'
                        }`}
                      >
                        {dataType.supported && dataType.permissionOk ? 'Available' : 'Action required'}
                      </span>
                    </div>
                    <div className="mt-2 space-y-1 text-xs text-text-muted">
                      {typeof dataType.approxCount === 'number' && (
                        <p>Approximate records: {dataType.approxCount.toLocaleString()}</p>
                      )}
                      {!dataType.permissionOk && dataType.missingScopes && dataType.missingScopes.length > 0 && (
                        <p>Missing scopes: {dataType.missingScopes.join(', ')}</p>
                      )}
                      {dataType.notes && <p>{dataType.notes}</p>}
                    </div>
                  </div>
                ))}
                {inspection.dataTypes.length === 0 && (
                  <div className="rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-4 text-sm text-text-muted">
                    Provider did not report any capabilities for this integration.
                  </div>
                )}
              </div>
            </div>

            {inspection.recommendedMappings && Object.keys(inspection.recommendedMappings).length > 0 && (
              <div className="space-y-3">
                <h3 className="text-sm font-semibold uppercase tracking-wide text-text-secondary">
                  Recommended field mappings
                </h3>
                <div className="space-y-3">
                  {Object.entries(inspection.recommendedMappings).map(([dataType, mappings]) => (
                    <div
                      key={dataType}
                      className="rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-4"
                    >
                      <h4 className="text-sm font-semibold text-text-primary">{dataType}</h4>
                      <ul className="mt-2 space-y-1 text-xs text-text-muted">
                        {mappings.map((mapping) => (
                          <li key={`${mapping.sourceField}-${mapping.targetField}`}>
                            <span className="font-medium text-text-primary">{mapping.sourceField}</span> →{' '}
                            {mapping.targetField}
                            {mapping.required ? ' (required)' : ''}
                            {mapping.sampleValue ? ` — e.g. ${String(mapping.sampleValue)}` : ''}
                          </li>
                        ))}
                      </ul>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className="rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-4 text-sm text-text-muted">
            No inspection data available for this integration.
          </div>
        )}
      </div>
    </div>
  );
};

type InspectModalContainerProps = {
  integration: IntegrationStatusResponse;
  onClose: () => void;
};

const InspectModalContainer: React.FC<InspectModalContainerProps> = ({ integration, onClose }) => {
  const [inspection, setInspection] = useState<IntegrationInspection | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    let isActive = true;
    setIsLoading(true);
    setError(null);
    setInspection(null);

    inspectIntegration(integration.id)
      .then((result) => {
        if (!isActive) return;
        setInspection(result);
      })
      .catch((err) => {
        if (!isActive) return;
        const problem = parseIntegrationProblem(err);
        logIntegrationProblem('Inspect integration capabilities failed', problem, { integrationId: integration.id });
        setError(problem.detail ?? 'Unable to fetch provider capabilities.');
      })
      .finally(() => {
        if (isActive) {
          setIsLoading(false);
        }
      });

    return () => {
      isActive = false;
    };
  }, [integration.id]);

  return (
    <InspectModal
      integration={integration}
      inspection={inspection}
      isLoading={isLoading}
      error={error}
      onClose={onClose}
    />
  );
};

type SyncJobsSectionProps = {
  jobs: IntegrationSyncJobSummary[];
  isLoading: boolean;
  onRefresh: () => void;
  integrationOptions: Array<{ value: string; label: string }>;
  selectedIntegrationId: string;
  onFilterChange: (value: string) => void;
  integrationLookup: Record<string, string>;
};

const SyncJobsSection: React.FC<SyncJobsSectionProps> = ({
  jobs,
  isLoading,
  onRefresh,
  integrationOptions,
  selectedIntegrationId,
  onFilterChange,
  integrationLookup,
}) => {
  return (
    <div className="rounded-2xl border border-border-primary/40 bg-surface-primary/80 p-6 shadow-xl">
      <div className="mb-4 flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 className="text-lg font-semibold text-text-primary">Sync job dashboard</h2>
          <p className="text-sm text-text-secondary">
            Review Hangfire job cadence, last execution, and upcoming schedules.
          </p>
        </div>
        <div className="flex flex-wrap items-center gap-3">
          <select
            value={selectedIntegrationId}
            onChange={(event) => onFilterChange(event.target.value)}
            className="rounded-lg border border-border-primary/50 bg-surface-secondary/80 px-3 py-2 text-sm text-text-primary focus:border-accent-primary focus:outline-none"
          >
            {integrationOptions.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
          <Button variant="outline" size="sm" onClick={onRefresh} isLoading={isLoading}>
            Refresh jobs
          </Button>
        </div>
      </div>

      {isLoading ? (
        <div className="flex items-center justify-center py-10">
          <Spinner size="lg" className="text-accent-primary" />
        </div>
      ) : jobs.length === 0 ? (
        <div className="rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-6 text-center text-sm text-text-muted">
          No recurring sync jobs detected. Enable scheduled sync or run a manual sync to create new jobs.
        </div>
      ) : (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-border-primary/40 text-left text-sm">
            <thead className="bg-surface-secondary/70">
              <tr className="text-xs uppercase tracking-wide text-text-secondary">
                <th className="px-4 py-3 font-semibold">Integration</th>
                <th className="px-4 py-3 font-semibold">Job ID</th>
                <th className="px-4 py-3 font-semibold">Last execution</th>
                <th className="px-4 py-3 font-semibold">Next execution</th>
                <th className="px-4 py-3 font-semibold">State</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-border-primary/20">
              {jobs.map((job) => (
                <tr key={job.jobId} className="text-sm text-text-secondary">
                  <td className="px-4 py-3 text-text-primary">
                    {integrationLookup[job.integrationId] ?? job.integrationId}
                  </td>
                  <td className="px-4 py-3 text-text-muted">{job.jobId}</td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col">
                      <span className="text-text-primary">{formatAbsolute(job.lastExecution)}</span>
                      <span className="text-xs text-text-muted">{formatRelativeTime(job.lastExecution)}</span>
                    </div>
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col">
                      <span className="text-text-primary">{formatAbsolute(job.nextExecution)}</span>
                      <span className="text-xs text-text-muted">{formatRelativeTime(job.nextExecution)}</span>
                    </div>
                  </td>
                  <td className="px-4 py-3">
                    <span
                      className={`rounded-full px-2 py-1 text-xs font-medium ${
                        job.isProcessing
                          ? 'bg-info/20 text-info'
                          : job.lastJobState === 'Succeeded'
                          ? 'bg-success/20 text-success'
                          : job.lastJobState === 'Failed'
                          ? 'bg-error/20 text-error-muted'
                          : 'bg-surface-secondary/70 text-text-secondary'
                      }`}
                    >
                      {job.isProcessing ? 'Running' : job.lastJobState ?? 'Unknown'}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};

type IntegrationConfigModalContainerProps = {
  integration: IntegrationStatusResponse;
  onClose: () => void;
  onConfigured: () => void;
};

const IntegrationConfigModalContainer: React.FC<IntegrationConfigModalContainerProps> = ({
  integration,
  onClose,
  onConfigured,
}) => {
  const { addNotification } = useNotifications();
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const {
    data: configOptions,
    isLoading: isConfigOptionsLoading,
  } = useGetConfigurationOptions(integration.type, {
    enabled: Boolean(integration.type),
  });

  const {
    data: inspection,
    isLoading: isInspectionLoading,
  } = useInspectIntegration(integration.id, {
    enabled: Boolean(integration.id),
  });

  const configureMutation = useConfigureIntegration({
    onSuccess: () => {
      addNotification({
        type: 'success',
        title: 'Configuration saved',
        message: 'Sync preferences updated successfully.',
      });
      setErrorMessage(null);
      onConfigured();
      onClose();
    },
    onError: (error) => {
      const problem = parseIntegrationProblem(error);
      logIntegrationProblem('Save integration configuration failed', problem, { integrationId: integration.id });
      const metadata = problem.metadata as Record<string, unknown> | undefined;
      const missing = Array.isArray(metadata?.requiredKeys) ? metadata?.requiredKeys : undefined;
      if (missing && missing.length > 0) {
        setErrorMessage(
          `${problem.detail ?? 'Missing required configuration keys.'} (${missing.join(', ')})`
        );
      } else {
        setErrorMessage(problem.detail ?? 'Unable to save configuration settings.');
      }
    },
  });

  const handleSubmit = async (config: SyncConfigRequest) => {
    await configureMutation.mutateAsync({ integrationId: integration.id, config });
  };

  return (
    <IntegrationConfigModal
      open
      integration={integration}
      options={configOptions}
      inspection={inspection}
      isLoading={isConfigOptionsLoading || isInspectionLoading}
      isSaving={configureMutation.isPending}
      errorMessage={errorMessage}
      onClose={onClose}
      onSubmit={handleSubmit}
    />
  );
};

type ManualSyncModalContainerProps = {
  integration: IntegrationStatusResponse;
  onClose: () => void;
  onSyncStart: (integrationId: string) => void;
  onSyncSettled: () => void;
  onSyncSuccess: () => void;
};

const ManualSyncModalContainer: React.FC<ManualSyncModalContainerProps> = ({
  integration,
  onClose,
  onSyncStart,
  onSyncSettled,
  onSyncSuccess,
}) => {
  const { addNotification } = useNotifications();
  const [incrementalSync, setIncrementalSync] = useState(true);
  const [syncFromDate, setSyncFromDate] = useState('');

  useEffect(() => {
    setIncrementalSync(true);
    setSyncFromDate('');
  }, [integration.id]);

  const triggerSyncMutation = useTriggerSync({
    onMutate: ({ integrationId }) => {
      onSyncStart(integrationId);
    },
    onSuccess: (result) => {
      addNotification({
        type: 'success',
        title: 'Sync started',
        message: result.syncJobId
          ? `Job ${result.syncJobId} queued successfully.`
          : 'Manual sync started successfully.',
      });
      onSyncSuccess();
      onClose();
    },
    onError: (error) => {
      const problem = parseIntegrationProblem(error);
      logIntegrationProblem('Trigger manual sync failed', problem, { integrationId: integration.id });
      const metadata = problem.metadata as Record<string, unknown> | undefined;
      const recommended =
        metadata && typeof metadata.recommendedAction === 'string'
          ? metadata.recommendedAction
          : undefined;
      const baseDetail =
        problem.detail ??
        (problem.code === 'Integration.SyncInProgress'
          ? 'A sync is already running for this integration.'
          : 'Sync request could not be queued. Check the integration status and try again.');
      addNotification({
        type: problem.code === 'Integration.SyncInProgress' ? 'warning' : 'error',
        title: problem.code === 'Integration.SyncInProgress' ? 'Sync already in progress' : 'Manual sync failed',
        message: recommended ? `${baseDetail} ${recommended}` : baseDetail,
      });
    },
    onSettled: () => {
      onSyncSettled();
    },
  });

  const handleSubmit = async () => {
    let parsedDate: Date | null = null;
    if (syncFromDate) {
      const candidate = new Date(syncFromDate);
      parsedDate = Number.isNaN(candidate.getTime()) ? null : candidate;
    }

    await triggerSyncMutation.mutateAsync({
      integrationId: integration.id,
      options: {
        incrementalSync,
        syncFromDate: parsedDate ?? undefined,
      },
    });
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-bg-primary/60 backdrop-blur-sm p-4">
      <div className="w-full max-w-lg rounded-2xl border border-border-primary/40 bg-surface-primary/95 p-6 shadow-2xl">
        <div className="mb-4">
          <h2 className="text-lg font-semibold text-text-primary">Trigger manual sync</h2>
          <p className="text-sm text-text-secondary">
            Configure a one-off sync for <span className="font-medium text-text-primary">{integration.name}</span>.
          </p>
        </div>

        <div className="space-y-4">
          <label className="flex items-center gap-3 text-sm font-medium text-text-secondary">
            <input
              type="checkbox"
              className="h-4 w-4 rounded border-border-primary/60"
              checked={incrementalSync}
              onChange={(event) => setIncrementalSync(event.target.checked)}
            />
            Incremental sync (only new or updated records)
          </label>

          <div className="space-y-1 text-sm">
            <label className="font-medium text-text-secondary" htmlFor="manual-sync-date">
              Historical sync starting from
            </label>
            <input
              id="manual-sync-date"
              type="datetime-local"
              value={syncFromDate}
              onChange={(event) => setSyncFromDate(event.target.value)}
              className="w-full rounded-lg border border-border-primary/50 bg-surface-secondary/80 px-3 py-2 text-text-primary focus:border-accent-primary focus:outline-none"
            />
            <p className="text-xs text-text-muted">Leave blank to use the last successful sync checkpoint.</p>
          </div>
        </div>

        <div className="mt-6 flex flex-col gap-3 sm:flex-row sm:justify-end">
          <Button variant="outline" onClick={onClose} disabled={triggerSyncMutation.isPending}>
            Cancel
          </Button>
          <Button
            className="bg-gradient-to-r from-accent-primary to-accent-secondary text-white hover:from-accent-primary hover:to-accent-secondary"
            onClick={handleSubmit}
            disabled={triggerSyncMutation.isPending}
            isLoading={triggerSyncMutation.isPending}
          >
            Run Sync
          </Button>
        </div>
      </div>
    </div>
  );
};

export const IntegrationsSection: React.FC = () => {
  const { addNotification } = useNotifications();
  const { checkCompanyPolicy } = useAuthorization();
  const { openModal, closeModal } = useModal();
  const navigate = useNavigate();
  const canManageIntegrations = checkCompanyPolicy('integrations:write');
  const [searchParams, setSearchParams] = useSearchParams();
  const handledDeepLinkRef = useRef<string | null>(null);

  const [typeFilter, setTypeFilter] = useState<string>('all');
  const [statusFilter, setStatusFilter] = useState<'all' | IntegrationStatus>('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [syncingIntegrationId, setSyncingIntegrationId] = useState<string | null>(null);
  const [testingIntegrationId, setTestingIntegrationId] = useState<string | null>(null);
  const [disconnectingIntegrationId, setDisconnectingIntegrationId] = useState<string | null>(null);
  const [reconnectingIntegrationId, setReconnectingIntegrationId] = useState<string | null>(null);
  const [connectingType, setConnectingType] = useState<string | null>(null);
  const [jobFilterIntegrationId, setJobFilterIntegrationId] = useState<string>('all');

  useEffect(() => {
    cleanupExpiredOAuthSessions();
  }, []);

  const integrationQueryParams = useMemo(
    () => ({
      type: typeFilter === 'all' ? undefined : typeFilter,
      status: statusFilter === 'all' ? undefined : statusFilter,
    }),
    [typeFilter, statusFilter]
  );

  const {
    data: integrations = [],
    isLoading,
    isFetching,
    refetch,
  } = useGetIntegrations(integrationQueryParams);

  const { data: configurationOptionsMap } = useGetAllConfigurationOptions();

  const {
    data: syncJobs = [],
    isFetching: isSyncJobsFetching,
    refetch: refetchJobs,
  } = useGetSyncJobs(jobFilterIntegrationId === 'all' ? undefined : jobFilterIntegrationId);

  const startConnectionMutation = useStartConnection({
    onMutate: (type) => {
      setConnectingType(type);
    },
    onSuccess: (result, integrationType) => {
      const meta = getProviderMetadata(integrationType);
      addNotification({
        type: 'info',
        title: `Connecting ${meta.name}`,
        message: 'Redirecting to the provider to authorise access.',
      });
      persistOAuthSession({
        type: integrationType,
        state: result.state,
        existingIntegrationId: result.existingIntegrationId ?? null,
      });
      window.location.assign(result.authorizationUrl);
    },
    onError: (error, integrationType) => {
      const problem = parseIntegrationProblem(error);
      const meta = getProviderMetadata(integrationType);
      logIntegrationProblem('Start integration connection failed', problem, { integrationType });

      if (problem.code === 'Integration.AlreadyExists' && problem.metadata && typeof problem.metadata === 'object') {
        const metadata = problem.metadata as Record<string, unknown>;
        const existingId = metadata.existingIntegrationId ? String(metadata.existingIntegrationId) : undefined;
        const nextAction = metadata.nextAction ? String(metadata.nextAction) : undefined;
        addNotification({
          type: 'warning',
          title: `${meta.name} already connected`,
          message:
            problem.detail ??
            (nextAction
              ? `Use the reconnect action (${nextAction}) to refresh credentials.`
              : 'Try reconnecting from the integrations list.'),
        });

        if (existingId) {
          const target = integrations.find((item) => item.id === existingId);
          if (target) {
            handleOpenConfig(target);
          }
        }
      } else {
        addNotification({
          type: 'error',
          title: `Unable to connect ${meta.name}`,
          message: problem.detail ?? 'Unexpected error while starting OAuth flow.',
        });
      }
    },
    onSettled: () => {
      setConnectingType(null);
    },
  });

  const reconnectMutation = useReconnectIntegration({
    onMutate: (integrationId) => {
      setReconnectingIntegrationId(integrationId);
    },
    onSuccess: (result) => {
      addNotification({
        type: 'info',
        title: 'Reconnect required',
        message: 'Redirecting you to refresh the integration credentials.',
      });

      if (result.authorizationUrl) {
        window.location.assign(result.authorizationUrl);
      } else {
        addNotification({
          type: 'warning',
          title: 'Reconnect pending',
          message: result.message ?? 'Follow the instructions returned by the API to reconnect.',
        });
      }
    },
    onError: (error, integrationId) => {
      const problem = parseIntegrationProblem(error);
      logIntegrationProblem('Reconnect integration failed', problem, { integrationId });
      addNotification({
        type: 'error',
        title: 'Reconnect failed',
        message: problem.detail ?? 'Unable to start reconnect flow. Try again shortly.',
      });
    },
    onSettled: () => {
      setReconnectingIntegrationId(null);
    },
  });

  const testConnectionMutation = useTestConnection({
    onMutate: (integrationId) => {
      setTestingIntegrationId(integrationId);
    },
    onSuccess: (result) => {
      addNotification({
        type: result.isConnected ? 'success' : 'warning',
        title: 'Connection test complete',
        message: result.message ?? `Status: ${result.status}`,
      });
    },
    onError: (error, integrationId) => {
      const problem = parseIntegrationProblem(error);
      logIntegrationProblem('Test integration connection failed', problem, { integrationId });
      addNotification({
        type: 'error',
        title: 'Connection test failed',
        message: problem.detail ?? 'Integration test endpoint returned an error.',
      });
    },
    onSettled: () => {
      setTestingIntegrationId(null);
    },
  });

  const disconnectMutation = useDisconnectIntegration({
    onMutate: (integrationId) => {
      setDisconnectingIntegrationId(integrationId);
    },
    onSuccess: (result) => {
      addNotification({
        type: 'success',
        title: 'Integration disconnected',
        message: result.message,
      });
      refetch();
      refetchJobs();
    },
    onError: (error, integrationId) => {
      const problem = parseIntegrationProblem(error);
      logIntegrationProblem('Disconnect integration failed', problem, { integrationId });
      const metadata = problem.metadata as Record<string, unknown> | undefined;
      const recommended =
        metadata && typeof metadata.recommendedAction === 'string'
          ? metadata.recommendedAction
          : undefined;
      addNotification({
        type: 'error',
        title: 'Failed to disconnect integration',
        message: recommended
          ? `${problem.detail ?? 'Please try again after resolving any outstanding sync jobs.'} ${recommended}`
          : problem.detail ?? 'Please try again after resolving any outstanding sync jobs.',
      });
    },
    onSettled: () => {
      setDisconnectingIntegrationId(null);
    },
  });

  const normalizedSearch = searchTerm.trim().toLowerCase();

  const filteredIntegrations = useMemo(() => {
    if (!normalizedSearch) {
      return integrations;
    }

    return integrations.filter((integration) => {
      const nameMatch = integration.name.toLowerCase().includes(normalizedSearch);
      const typeMatch = integration.type.toLowerCase().includes(normalizedSearch);
      return nameMatch || typeMatch;
    });
  }, [integrations, normalizedSearch]);

  const integrationTypes = useMemo(() => {
    const set = new Set<string>();
    Object.keys(PROVIDER_CATALOG).forEach((type) => set.add(type));
    integrations.forEach((integration) => set.add(integration.type));
    if (configurationOptionsMap) {
      Object.keys(configurationOptionsMap).forEach((type) => set.add(type));
    }
    Object.keys(PROVIDER_CATALOG).forEach((type) => set.add(type));
    return Array.from(set).sort((a, b) => a.localeCompare(b));
  }, [integrations, configurationOptionsMap]);

  const typeFilterOptions = useMemo(() => ['all', ...integrationTypes], [integrationTypes]);

  const availableProviders = useMemo(() => {
    const connectedTypes = new Set(integrations.map((integration) => integration.type));
    return integrationTypes
      .filter((type) => !connectedTypes.has(type))
      .map(getProviderMetadata)
      .filter((provider) => {
        if (!normalizedSearch) {
          return true;
        }
        return provider.name.toLowerCase().includes(normalizedSearch);
      });
  }, [integrationTypes, integrations, normalizedSearch]);

  const connectedCount = integrations.filter((integration) => integration.status === IntegrationStatus.Connected).length;
  const needsAttentionCount = integrations.filter(
    (integration) =>
      integration.status === IntegrationStatus.Error ||
      integration.status === IntegrationStatus.TokenExpired ||
      integration.needsTokenRefresh ||
      integration.needsConfiguration
  ).length;
  const syncingCount = integrations.filter((integration) => integration.status === IntegrationStatus.Syncing).length;
  const totalSyncedRecords = integrations.reduce(
    (total, integration) => total + (integration.syncedRecordCount ?? 0),
    0
  );

  const handleOpenConfig = useCallback(
    (integration: IntegrationStatusResponse) => {
      openModal(
        <IntegrationConfigModalContainer
          key={`config-${integration.id}`}
          integration={integration}
          onClose={closeModal}
          onConfigured={() => {
            refetch();
            refetchJobs();
          }}
        />,
      );
    },
    [openModal, closeModal, refetch, refetchJobs],
  );

  const handleOpenManualSync = useCallback(
    (integration: IntegrationStatusResponse) => {
      openModal(
        <ManualSyncModalContainer
          key={`manual-sync-${integration.id}`}
          integration={integration}
          onClose={closeModal}
          onSyncStart={(integrationId) => setSyncingIntegrationId(integrationId)}
          onSyncSettled={() => setSyncingIntegrationId(null)}
          onSyncSuccess={() => {
            refetch();
            refetchJobs();
          }}
        />,
      );
    },
    [openModal, closeModal, refetch, refetchJobs],
  );

  const handleOpenInspect = useCallback(
    (integration: IntegrationStatusResponse) => {
      openModal(
        <InspectModalContainer
          key={`inspect-${integration.id}`}
          integration={integration}
          onClose={closeModal}
        />,
      );
    },
    [openModal, closeModal],
  );

  const handleRequireConfiguration = useCallback(
    (integrationId: string, metadata?: Record<string, unknown>) => {
      const endpointValue =
        metadata && typeof (metadata as Record<string, unknown>).configurationEndpoint === 'string'
          ? String((metadata as Record<string, unknown>).configurationEndpoint)
          : undefined;

      if (endpointValue) {
        if (/^https?:\/\//i.test(endpointValue)) {
          window.location.assign(endpointValue);
          return;
        }

        navigate(endpointValue, { replace: false });
        return;
      }

      const targetIntegration = integrations.find((item) => item.id === integrationId);
      if (targetIntegration) {
        handleOpenConfig(targetIntegration);
        return;
      }

      const params = new URLSearchParams();
      params.set('integrationId', integrationId);
      params.set('action', 'configure');
      setSearchParams(params, { replace: false });
    },
    [integrations, navigate, handleOpenConfig, setSearchParams],
  );
  const handleDisconnect = (integration: IntegrationStatusResponse) => {
    const confirmed = window.confirm(
      'Disconnecting will stop all scheduled syncs and remove stored credentials. Continue?'
    );
    if (!confirmed) {
      return;
    }

    disconnectMutation.mutate(integration.id);
  };

  const jobFilterOptions = useMemo(() => {
    const base = [
      { value: 'all', label: 'All integrations' },
      ...integrations.map((integration) => ({
        value: integration.id,
        label: integration.name,
      })),
    ];
    return base;
  }, [integrations]);

  const integrationLookup = useMemo(() => {
    const result: Record<string, string> = {};
    for (const integration of integrations) {
      result[integration.id] = integration.name;
    }
    return result;
  }, [integrations]);

  useEffect(() => {
    if (isLoading) {
      return;
    }

    const targetId = searchParams.get('integrationId');
    const action = searchParams.get('action');
    if (!targetId) {
      handledDeepLinkRef.current = null;
      return;
    }

    const handleKey = `${targetId}:${action ?? ''}`;
    if (handledDeepLinkRef.current === handleKey) {
      return;
    }

    const targetIntegration = integrations.find((integration) => integration.id === targetId);
    if (!targetIntegration) {
      return;
    }

    handledDeepLinkRef.current = handleKey;

    if (action === 'manual-sync') {
      handleOpenManualSync(targetIntegration);
    } else if (action === 'inspect') {
      handleOpenInspect(targetIntegration);
    } else {
      // Default action: open configuration, especially when needsConfiguration is flagged
      handleOpenConfig(targetIntegration);
    }

    const next = new URLSearchParams(searchParams);
    next.delete('integrationId');
    next.delete('action');
    setSearchParams(next, { replace: true });
  }, [
    integrations,
    isLoading,
    searchParams,
    setSearchParams,
    handleOpenConfig,
    handleOpenManualSync,
    handleOpenInspect,
  ]);

  useEffect(() => {
    const handleSyncStarted = (payload: { integrationId?: string; message?: string }) => {
      if (payload?.message) {
        addNotification({
          type: 'info',
          title: 'Sync started',
          message: payload.message,
        });
      }

      if (payload?.integrationId) {
        setSyncingIntegrationId(payload.integrationId);
      }

      refetch();
      refetchJobs();
    };

    const handleSyncCompleted = (payload: { integrationId?: string; message?: string }) => {
      if (payload?.message) {
        addNotification({
          type: 'success',
          title: 'Sync completed',
          message: payload.message,
        });
      }

      if (payload?.integrationId) {
        setSyncingIntegrationId((current) => (current === payload.integrationId ? null : current));
      }

      refetch();
      refetchJobs();
    };

    const handleSyncFailed = (payload: { integrationId?: string; message?: string }) => {
      addNotification({
        type: 'error',
        title: 'Sync failed',
        message: payload?.message ?? 'Sync job reported a failure.',
      });

      if (payload?.integrationId) {
        setSyncingIntegrationId((current) => (current === payload.integrationId ? null : current));
      }

      refetch();
      refetchJobs();
    };

    signalRConnection.on('integrations/sync-started', handleSyncStarted);
    signalRConnection.on('integrations/sync-completed', handleSyncCompleted);
    signalRConnection.on('integrations/sync-failed', handleSyncFailed);

    return () => {
      signalRConnection.off('integrations/sync-started', handleSyncStarted);
      signalRConnection.off('integrations/sync-completed', handleSyncCompleted);
      signalRConnection.off('integrations/sync-failed', handleSyncFailed);
    };
  }, [addNotification, refetch, refetchJobs]);

  return (
    <div className="space-y-8">
      <div className="rounded-2xl border border-border-primary/40 bg-surface-primary/80 p-6 shadow-xl">
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/60 p-4">
            <p className="text-xs uppercase tracking-wide text-text-muted">Connected integrations</p>
            <p className="mt-2 text-2xl font-semibold text-text-primary">{connectedCount}</p>
          </div>
          <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/60 p-4">
            <p className="text-xs uppercase tracking-wide text-text-muted">Needs attention</p>
            <p className="mt-2 text-2xl font-semibold text-warning-muted">{needsAttentionCount}</p>
          </div>
          <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/60 p-4">
            <p className="text-xs uppercase tracking-wide text-text-muted">Active syncs</p>
            <p className="mt-2 text-2xl font-semibold text-info">{syncingCount}</p>
          </div>
          <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/60 p-4">
            <p className="text-xs uppercase tracking-wide text-text-muted">Total records synced</p>
            <p className="mt-2 text-2xl font-semibold text-text-primary">{totalSyncedRecords.toLocaleString()}</p>
          </div>
        </div>
      </div>

      <div className="rounded-2xl border border-border-primary/40 bg-surface-primary/80 p-6 shadow-xl">
        <div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
          <div className="flex flex-wrap items-center gap-3">
            <select
              value={typeFilter}
              onChange={(event) => setTypeFilter(event.target.value)}
              className="rounded-lg border border-border-primary/50 bg-surface-secondary/80 px-3 py-2 text-sm text-text-primary focus:border-accent-primary focus:outline-none"
            >
              {typeFilterOptions.map((option) => (
                <option key={option} value={option}>
                  {option === 'all' ? 'All providers' : getProviderMetadata(option).name}
                </option>
              ))}
            </select>

            <select
              value={statusFilter}
              onChange={(event) => setStatusFilter(event.target.value as 'all' | IntegrationStatus)}
              className="rounded-lg border border-border-primary/50 bg-surface-secondary/80 px-3 py-2 text-sm text-text-primary focus:border-accent-primary focus:outline-none"
            >
              <option value="all">Any status</option>
              <option value={IntegrationStatus.Connected}>Connected</option>
              <option value={IntegrationStatus.NotConnected}>Not connected</option>
              <option value={IntegrationStatus.TokenExpired}>Token expired</option>
              <option value={IntegrationStatus.Error}>Error</option>
              <option value={IntegrationStatus.Syncing}>Syncing</option>
            </select>
          </div>

          <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
            <input
              value={searchTerm}
              onChange={(event) => setSearchTerm(event.target.value)}
              placeholder="Search integrations..."
              className="w-full rounded-lg border border-border-primary/50 bg-surface-secondary/80 px-3 py-2 text-sm text-text-primary focus:border-accent-primary focus:outline-none sm:min-w-[240px]"
            />
            <Button variant="outline" onClick={() => refetch()} isLoading={isFetching}>
              Refresh list
            </Button>
          </div>
        </div>

        {isLoading ? (
          <div className="flex items-center justify-center py-16">
            <Spinner size="lg" className="text-accent-primary" />
          </div>
        ) : filteredIntegrations.length === 0 ? (
          <div className="mt-8 rounded-xl border border-border-primary/40 bg-surface-secondary/70 p-8 text-center text-sm text-text-muted">
            No integrations match the current filters. Connect a provider below or adjust the filters.
          </div>
        ) : (
          <div className="mt-8 space-y-6">
            {filteredIntegrations.map((integration) => {
              const meta = getProviderMetadata(integration.type);
              const accentGradient = meta.accentGradient ?? CATEGORY_GRADIENTS[meta.category] ?? CATEGORY_GRADIENTS.other;
              const primaryActionClass = `bg-gradient-to-r ${accentGradient} text-white shadow-md hover:shadow-xl`;
              const configOptions = configurationOptionsMap?.[integration.type] as ConfigurationOptions | undefined;
              const showReconnect =
                integration.status === IntegrationStatus.TokenExpired ||
                integration.needsTokenRefresh ||
                integration.status === IntegrationStatus.Error;
              const isSyncing =
                syncingIntegrationId === integration.id || integration.status === IntegrationStatus.Syncing;
              const connectedAt = integration.connectionDetails?.connectedAt;
              const syncConfig = integration.syncConfiguration;

              return (
                <div
                  key={integration.id}
                  className="relative overflow-hidden rounded-2xl border border-border-primary/40 bg-surface-primary/95 p-6 shadow-lg transition hover:border-border-primary/60 hover:shadow-xl"
                >
                  <div
                    className={`pointer-events-none absolute inset-y-0 left-0 w-1 bg-gradient-to-b ${accentGradient}`}
                    aria-hidden="true"
                  />
                  <div className="flex flex-col gap-6">
                    <div className="flex flex-col gap-4 md:flex-row md:items-start md:justify-between">
                      <div className="flex items-start gap-4">
                        <ProviderIcon provider={meta} size="lg" />
                        <div>
                          <div className="flex flex-wrap items-center gap-3">
                            <h3 className="text-lg font-semibold text-text-primary">{integration.name}</h3>
                            <StatusBadge status={integration.status} />
                            {integration.needsConfiguration && (
                              <span className="rounded-full bg-warning/15 px-2.5 py-1 text-xs font-medium text-warning">
                                Needs configuration
                              </span>
                            )}
                          </div>
                          <p className="mt-1 text-sm text-text-secondary">{meta.description}</p>
                          <div className="mt-3 flex flex-wrap items-center gap-2 text-xs text-text-muted">
                            <span className="rounded-full bg-surface-secondary/70 px-2 py-1 font-medium text-text-secondary">
                              {integration.type}
                            </span>
                            {connectedAt && (
                              <span>
                                Connected {formatRelativeTime(connectedAt)} ({formatAbsolute(connectedAt)})
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                      <div className="flex flex-col gap-2 text-xs">
                        {integration.tokenExpiresAt && (
                          <span className="rounded-full bg-warning/15 px-3 py-1 font-medium text-warning">
                            Token expires {formatRelativeTime(integration.tokenExpiresAt)} (
                            {formatAbsolute(integration.tokenExpiresAt)})
                          </span>
                        )}
                        {integration.needsTokenRefresh && (
                          <span className="rounded-full bg-warning/10 px-3 py-1 text-warning-muted">
                            Refresh recommended
                          </span>
                        )}
                      </div>
                    </div>

                    <div className="grid gap-4 md:grid-cols-3">
                      <StatCard
                        label="Records synced"
                        value={integration.syncedRecordCount.toLocaleString()}
                        helper={isSyncing ? 'Sync currently running' : 'Cumulative total'}
                      />
                      <StatCard
                        label="Last sync"
                        value={formatRelativeTime(integration.lastSyncedAt)}
                        helper={formatAbsolute(integration.lastSyncedAt)}
                      />
                      <StatCard
                        label="Next sync"
                        value={formatRelativeTime(integration.nextSyncAt)}
                        helper={formatAbsolute(integration.nextSyncAt)}
                      />
                    </div>

                    <div className="rounded-xl border border-border-primary/30 bg-surface-secondary/70 p-4">
                      <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
                        <div>
                          <p className="text-sm font-semibold text-text-primary">Sync configuration</p>
                          <p className="text-xs text-text-muted">
                            Preferences persisted from the configure endpoint.
                          </p>
                        </div>
                        {showReconnect && (
                          <span className="rounded-full bg-warning/10 px-3 py-1 text-xs font-medium text-warning">
                            Action required
                          </span>
                        )}
                      </div>
                      {syncConfig ? (
                        <div className="mt-4 grid gap-4 md:grid-cols-2">
                          <div className="space-y-3 text-sm text-text-secondary">
                            <div>
                              <span className="text-xs uppercase tracking-wide text-text-muted">Frequency</span>
                              <p className="mt-1 font-medium text-text-primary">{syncConfig.syncFrequency}</p>
                            </div>
                            <div>
                              <span className="text-xs uppercase tracking-wide text-text-muted">Data sets</span>
                              <div className="mt-2 flex flex-wrap gap-2">
                                {(syncConfig.dataTypes ?? []).map((dataType) => (
                                  <span
                                    key={dataType}
                                    className="rounded-full bg-surface-secondary/60 px-2 py-1 text-xs text-text-secondary"
                                  >
                                    {dataType}
                                  </span>
                                ))}
                              </div>
                            </div>
                            <div className="flex flex-wrap gap-4 text-xs text-text-muted">
                              <span>Historical range: {syncConfig.historicalSyncDays} days</span>
                              <span>Batch size: {syncConfig.batchSize}</span>
                            </div>
                          </div>
                          <div className="space-y-3 text-xs text-text-secondary">
                            {syncConfig.lastSuccessfulSync && (
                              <div>
                                <span className="font-medium text-text-primary">Last successful sync</span>
                                <p>{formatAbsolute(syncConfig.lastSuccessfulSync)}</p>
                              </div>
                            )}
                            {syncConfig.nextScheduledSync && (
                              <div>
                                <span className="font-medium text-text-primary">Next scheduled sync</span>
                                <p>{formatAbsolute(syncConfig.nextScheduledSync)}</p>
                              </div>
                            )}
                            {syncConfig.customFields && Object.keys(syncConfig.customFields).length > 0 && (
                              <div>
                                <span className="font-medium text-text-primary">Custom fields</span>
                                <div className="mt-1 flex flex-wrap gap-2">
                                  {Object.keys(syncConfig.customFields).map((key) => (
                                    <span
                                      key={key}
                                      className="rounded-md bg-surface-secondary/80 px-2 py-1 text-[11px] uppercase tracking-wide text-text-muted"
                                    >
                                      {key}
                                    </span>
                                  ))}
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      ) : (
                        <div className="mt-4 rounded-lg border border-warning/30 bg-warning/10 p-4 text-sm text-warning-muted">
                          Sync configuration not supplied yet.
                        </div>
                      )}
                      {configOptions && (
                        <div className="mt-4 flex flex-wrap gap-3 text-[11px] text-text-muted">
                          <span>Default cadence: {configOptions.syncFrequencyOptions[0]?.label ?? 'Manual'}</span>
                          <span>Max range: {configOptions.maxHistoricalSyncDays} days</span>
                          <span>Max batch size: {configOptions.maxBatchSize}</span>
                        </div>
                      )}
                    </div>

                    {integration.errorMessage && (
                      <div className="rounded-xl border border-error/40 bg-error/15 p-4 text-sm text-error-muted">
                        {integration.errorMessage}
                      </div>
                    )}

                    <CompanyAuthorization policyCheck={canManageIntegrations}>
                      <div className="flex flex-col gap-3 border-t border-border-primary/30 pt-4 md:flex-row md:items-center md:justify-between">
                        <p className="text-xs text-text-muted">
                          {integration.isConnected
                            ? isSyncing
                              ? 'Sync in progress - manual actions are temporarily disabled.'
                              : 'Manual controls take effect immediately for this integration.'
                            : 'Start the OAuth flow to enable this integration.'}
                        </p>
                        <div className="flex flex-wrap items-center gap-3">
                          {integration.isConnected ? (
                            <>
                              <Button onClick={() => handleOpenConfig(integration)} className={primaryActionClass}>
                                Edit configuration
                              </Button>
                              <Button
                                variant="outline"
                                onClick={() => handleOpenManualSync(integration)}
                                isLoading={syncingIntegrationId === integration.id}
                                disabled={isSyncing}
                              >
                                {isSyncing ? 'Syncing...' : 'Manual sync'}
                              </Button>
                              <Button
                                variant="outline"
                                onClick={() => testConnectionMutation.mutate(integration.id)}
                                isLoading={testingIntegrationId === integration.id}
                              >
                                Test connection
                              </Button>
                              <Button variant="outline" onClick={() => handleOpenInspect(integration)}>
                                Inspect capabilities
                              </Button>
                              <Button
                                variant="outline"
                                onClick={() => handleDisconnect(integration)}
                                className="text-error-muted"
                                isLoading={disconnectingIntegrationId === integration.id}
                              >
                                Disconnect
                              </Button>
                            </>
                          ) : (
                            <Button
                              onClick={() => startConnectionMutation.mutate(integration.type)}
                              isLoading={connectingType === integration.type && startConnectionMutation.isPending}
                              className={primaryActionClass}
                            >
                              Connect
                            </Button>
                          )}
                          {showReconnect && (
                            <Button
                              variant="outline"
                              onClick={() => reconnectMutation.mutate(integration.id)}
                              isLoading={reconnectingIntegrationId === integration.id}
                            >
                              Refresh authorisation
                            </Button>
                          )}
                        </div>
                      </div>
                    </CompanyAuthorization>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>

      {availableProviders.length > 0 && (
        <div className="rounded-2xl border border-border-primary/40 bg-surface-primary/80 p-6 shadow-xl">
          <div className="mb-6">
            <h2 className="text-lg font-semibold text-text-primary">Available integrations</h2>
            <p className="text-sm text-text-secondary">
              Connect additional providers to bring more customer signals into PulseServer.
            </p>
          </div>
          <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
            {availableProviders.map((provider) => {
              const providerAccent =
                provider.accentGradient ?? CATEGORY_GRADIENTS[provider.category] ?? CATEGORY_GRADIENTS.other;
              const providerActionClass = `bg-gradient-to-r ${providerAccent} text-white shadow-md hover:shadow-xl`;

              return (
                <div
                  key={provider.type}
                  className="group relative overflow-hidden rounded-2xl border border-border-primary/30 bg-surface-primary/90 p-5 shadow-lg transition hover:border-border-primary/50 hover:shadow-2xl"
                >
                  <div
                    className={`absolute inset-x-0 top-0 h-1 bg-gradient-to-r ${providerAccent}`}
                    aria-hidden="true"
                  />
                  <div className="flex items-start justify-between gap-4">
                    <div className="flex items-start gap-3">
                      <ProviderIcon provider={provider} />
                      <div>
                        <div className="flex items-center gap-2">
                          <h3 className="text-base font-semibold text-text-primary">{provider.name}</h3>
                          <span className="rounded-full bg-surface-secondary/75 px-2 py-0.5 text-[11px] uppercase tracking-wide text-text-muted">
                            {provider.category.toUpperCase()}
                          </span>
                        </div>
                        <p className="mt-1 text-sm text-text-secondary">{provider.description}</p>
                      </div>
                    </div>
                  </div>
                  <div className="mt-4 flex flex-wrap gap-2">
                    {provider.features.map((feature) => (
                      <span
                        key={feature}
                        className="rounded-full bg-surface-secondary/70 px-2.5 py-1 text-xs text-text-secondary"
                      >
                        {feature}
                      </span>
                    ))}
                  </div>
                  <CompanyAuthorization policyCheck={canManageIntegrations}>
                    <Button
                      className={`mt-6 w-full justify-center ${providerActionClass}`}
                      onClick={() => startConnectionMutation.mutate(provider.type)}
                      isLoading={connectingType === provider.type && startConnectionMutation.isPending}
                    >
                      Connect {provider.name}
                    </Button>
                  </CompanyAuthorization>
                </div>
              );
            })}
          </div>
        </div>
      )}

      <SyncJobsSection
        jobs={syncJobs}
        isLoading={isSyncJobsFetching}
        onRefresh={refetchJobs}
        integrationOptions={jobFilterOptions}
        selectedIntegrationId={jobFilterIntegrationId}
        onFilterChange={setJobFilterIntegrationId}
        integrationLookup={integrationLookup}
      />

    </div>
  );
};

